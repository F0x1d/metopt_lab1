# Лабораторная работа №1: Решение задач линейного программирования

**ФИО:** Зотеев Максим Евгеньевич  
**Поток:** 1.2  

---

## Вариант задания

Решить задачу линейного программирования:

```
min Z = 3x₁ + 2x₂ + x₃ + 4x₄

При ограничениях:
    2x₁ + x₂ + x₃ ≤ 12
    x₂ + x₃ + x₄ = 9
    x₁ + x₄ ≥ 4
    xᵢ ≥ 0, i = 1,2,3,4
```

---

## Алгоритм решения задачи линейного программирования

### Общая схема

```
┌─────────────────────────────────────────┐
│  Чтение задачи из файла                 │
│  (целевая функция, ограничения)         │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Приведение к каноническому виду:       │
│  - Добавление остаточных переменных     │
│  - Добавление излишних переменных       │
│  - Добавление искусственных переменных  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Построение начальной симплекс-таблицы  │
│  - Формирование матрицы A               │
│  - Определение начального базиса        │
└──────────────┬──────────────────────────┘
               │
               ▼
         ┌─────────────┐
         │ Есть искусст│
         │ венные пере-│
         │ менные?     │
         └──────┬──────┘
                │
       Да       │       Нет
      ┌─────────┴─────────┐
      ▼                   ▼
┌─────────────────┐  ┌─────────────────┐
│  ФАЗА 1:        │  │  Переход к      │
│  Минимизация    │  │  ФАЗЕ 2         │
│  суммы искусст- │  │                 │
│  венных перемен-│  │                 │
│  ных            │  │                 │
└────────┬────────┘  └────────┬────────┘
         │                    │
         ▼                    │
┌─────────────────┐           │
│ Искусственные   │           │
│ переменные = 0? │           │
└────────┬────────┘           │
         │                    │
    Да   │   Нет              │
    ┌────┴────┐               │
    │         │               │
    ▼         ▼               │
┌────────┐ ┌──────────────┐  │
│ Фаза 2 │ │ Нет решений  │  │
└───┬────┘ └──────────────┘  │
    │                        │
    └────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│  ФАЗА 2: Симплекс-итерации              │
│                                         │
│  Цикл (пока не найдено оптимальное     │
│        решение):                        │
│  1. Выбор входящей переменной           │
│     (наиболее отрицательный коэфф.)     │
│  2. Выбор выходящей переменной          │
│     (минимальное отношение)             │
│  3. Преобразование Гаусса (поворот)     │
│  4. Обновление базиса                   │
│  5. Проверка оптимальности              │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Извлечение решения:                    │
│  - Значения переменных из базиса        │
│  - Вычисление целевой функции           │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Вывод и сохранение результата          │
└─────────────────────────────────────────┘
```

### Описание этапов алгоритма

#### 1. Чтение задачи из файла
Программа считывает постановку задачи из текстового файла `input.txt` в следующем формате:
- Тип оптимизации (min/max)
- Коэффициенты целевой функции
- Количество переменных
- Количество ограничений
- Ограничения (коэффициенты, тип, правая часть)

#### 2. Приведение к каноническому виду
Для каждого ограничения:
- **≤**: добавляется остаточная переменная (slack variable)
- **≥**: вычитается излишняя переменная и добавляется искусственная
- **=**: добавляется искусственная переменная

#### 3. Двухфазный симплекс-метод

**Фаза 1** (если требуются искусственные переменные):
- Минимизируется сумма всех искусственных переменных
- Если минимум равен 0, то найдено допустимое базисное решение
- Если минимум > 0, то задача не имеет допустимых решений

**Фаза 2** (решение основной задачи):
- Используется исходная целевая функция
- Выполняются симплекс-итерации до достижения оптимума
- На каждой итерации выбирается входящая и выходящая переменная
- Выполняется преобразование Гаусса (поворот)

#### 4. Критерии остановки
- Оптимум достигнут: все коэффициенты в z-строке неотрицательны
- Задача неограничена: нет подходящей выходящей переменной
- Нет допустимых решений: фаза 1 не дала нулевого значения

---

## Инструкция по запуску

### Требования
- Python 3.6 или выше
- Без внешних зависимостей (используется только стандартная библиотека Python)

### Формат входного файла (input.txt)
```
<тип>                      # min или max
<c1 c2 c3 ... cn>         # коэффициенты целевой функции
<количество_переменных>    # для проверки
<количество_ограничений>   # m
<a11 a12 ... a1n> <тип> <b1>  # первое ограничение
<a21 a22 ... a2n> <тип> <b2>  # второе ограничение
...
<am1 am2 ... amn> <тип> <bm>  # m-е ограничение
```

Где `<тип>` может быть: `<=`, `=`, `>=`

### Пример входного файла для данного варианта
```
min
3 2 1 4
4
3
2 1 1 0 <= 12
0 1 1 1 = 9
1 0 0 1 >= 4
```

### Запуск программы

```bash
cd /path/to/Lab1
python simplex.py
```

Программа:
1. Считает данные из `input.txt`
2. Выполнит решение задачи
3. Выведет результат на экран
4. Сохранит результат в `output.txt`

### Проверка решения

Подставим найденное решение **(x₁, x₂, x₃, x₄) = (0, 0, 5, 4)** в ограничения:

1. **2x₁ + x₂ + x₃ ≤ 12**  
   2(0) + 0 + 5 = 5 ≤ 12 ✓

2. **x₂ + x₃ + x₄ = 9**  
   0 + 5 + 4 = 9 ✓

3. **x₁ + x₄ ≥ 4**  
   0 + 4 = 4 ≥ 4 ✓

4. **xᵢ ≥ 0**  
   Все переменные неотрицательны ✓

**Значение целевой функции:**  
Z = 3(0) + 2(0) + 1(5) + 4(4) = 0 + 0 + 5 + 16 = **21** ✓

## Рефлективный вывод

### Что полезного было получено

1. **Глубокое понимание симплекс-метода**: Реализация алгоритма значительно улучшила понимание внутренней работы метода, особенно двухфазного подхода

2. **Работа с линейной алгеброй**: Практика в работе с матрицами, системами линейных уравнений

3. **Навыки отладки**: Пришлось столкнуться с различными граничными случаями и ошибками в логике, что улучшило навыки отладки

### Итоговая оценка

Работа оказалась очень полезной для закрепления теоретических знаний о симплекс-методе и получения практического опыта его реализации. Несмотря на возникшие трудности, процесс отладки и улучшения алгоритма был познавательным и помог глубже понять нюансы работы метода
